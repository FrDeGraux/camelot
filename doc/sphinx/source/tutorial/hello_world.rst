.. _tutorial-hello-world:

############
 Hello World
############

Creating a GUI application in **Camelot** is really easy.
The resulting application will offer some some compelling features, such as high
quality widgets, responsiveness (no screen freezes) and automatic data binding
between the model and the UI.
What's more, writing unit tests for a **Camelot** application is easy as well.

This tutorial will demonstrate how write a simple *Hello World* application and unit test it.

Get started
===========

If you you're not sure you have installed **Camelot** properly on your system,
please have a look at the :ref:`installation <doc-install>` part of the documentation.

Using your favourite text editor or IDE, create a file  called :file:`main.py`, and add these import statements :

.. literalinclude:: ../../../../test/snippet/hello_world/main.py
   :start-after: begin camelot imports
   :end-before: end camelot imports
  
Make sure you are able to execute this file, either through the IDE or from the command line ::

    python main.py

As this means the imports succeed, and **Camelot** is installed properly.

The **Camelot** library consists of a couple of modules, in this example, two of them are needed :

  * :mod:`camelot.admin` : high level definition of the user interaction, such as how forms
    and tables should look like, and the general flow of the application.

  * :mod:`camelot.view` : the reusable parts out of which the user interaction is build.  This
    includes editors and dialogs.

Define the application
======================

One of the basic concepts of **Camelot** are :ref:`actions <doc-actions>`.
Each Action class defines part of the flow of the application.
So each **Camelot** application should be a subclass of the :class:`camelot.admin.action.base.Action` class :

.. literalinclude:: ../../../../test/snippet/hello_world/main.py
   :start-after: begin application definition
   :end-before: end application definition

A subclass of the :class:`camelot.admin.action.base.Action` class, should overwrite the `model_run` generator.
A generator is like a normal method, but it has no `return` statement, instead it has one or more `yield` statements.

The `model_run` generator has a `yield` statement whenever it wants to interact with the user,
that is, ask the user a question, pop up a window or update the interface.
Each `yield` statement within the `model_run` method should yield a :class:`camelot.admin.action.base.ActionStep` object.

An :class:`ActionStep` class is a reusable part of the user interaction, there are steps to ask questions, display messages, show print previews, etc.
In this example, the :class:`camelot.view.action_steps.gui.MessageBox` step is used to show a message box to the user.

Run the application
===================

The last part needed is the construction of the action object,
named `hello_world` and to add some magic to get it running when :file:`main.py` is executed:

.. literalinclude:: ../../../../test/snippet/hello_world/main.py
   :start-after: begin application start magic
   :end-before: end application start magic

The complete application looks like this :

.. literalinclude:: ../../../../test/snippet/hello_world/main.py

It can be run from the command line, or from the IDE ::

    python main.py

In the case everything goes well, a *Hello World* dialog box should pop up.

.. image:: /_static/actionsteps/message_box.png

Writing unittests
=================

While everybody will agree that automated testing of an application is important to maintain quality over time,
it remains very difficult to perform automated unit testing of the user interaction.

**Camelot** was designed with test driven development in mind.
This means you can create your unittests before even starting to develop the application itself.

The complete application can be tested using nothing more than the `unittest` module from the standard library :

.. literalinclude:: ../../../../test/snippet/hello_world/test.py

Since the `model_run` method is a generator, all the unit test has to do is to loop over the steps generated by the method.
This simulates running the application, and each interaction with the user can be modelled.

Where to go from here
=====================

Where to go from here depends on the kind of application you want to build.  Here are some pointers :

  * Have a look at the various action steps that can be used :ref:`inside the model run method <doc-inside-model-run>`.

  * If you want to build **SQLAlchemy** based database applications, follow :ref:`this <tutorial-videostore>` tutorial.
  
  * Whatever the application you want to build, make sure you understand the :ref:`actions <doc-actions>`.

  * Get community support on the `mailing list <http://groups.google.com/group/project-camelot>`_.
  
  * Get commercial support from `Conceptive Engineering <http://www.conceptive.be>`_.
 